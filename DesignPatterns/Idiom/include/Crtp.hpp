#pragma once
#include "Common.hpp"
/*
	Curiously recurring template idiom
	It consists of an upside-down inheritance where the functionality is called from the Base class instead of the Derived one.

	It reduces the Memory Costs generated by runtime virtual functions when using polymorphism. Hence, CRTP is preferred when the object is to be called multiple times.

	Moreover, it also used to provide an object a progressive way to implement new functionalities
*/

/*
	>>>General implementation<<<
	template<typename T>
	class Base{
	public:
		void DoSomething(){
			static_cast<T&>(*this).setValue(3);
		}
	};
	class A : public Base<A>{
	public:
		void setValue(int x){
			//
		}
	};

	A a;
	a.DoSomething();
*/

namespace Idioms {

	//Helper traits for downcasting A from the base class
	template<typename T, template<typename> class crtpType>
	class crtp {
	public:
		T& derived() { return static_cast<T&>(*this); }
		T const& derived() const{ return static_cast<T const&>(*this); }

	private:
		//Compile-time verification of templates
		crtp() {}
		friend crtpType<T>;
	};

	template<typename T>
	class Scaler : crtp<T, Scaler> {
	public:
		void scale(int mt) {
			//provides meaning for static polymorphism, which is resolved at compile-time
			this->derived().setValue(this->derived().getValue() * mt);
		}

		void setToOpposite() {
			scale(-1);
		}
	private:
		// This provides compile-time verification of the template type
		// In case of class A : public Base<B>, compile will throw error since the private Base constructor can only be accessed by T. So the Derived class when instantiated needs to match typename T.
		Scaler() {}
		friend T;
	};

	template<typename T>
	class Doubler : crtp<T, Doubler> {
	public:
		void square() {
			int t = this->derived().getValue();
			this->derived().setValue(t * t);
		}
	private:
		// Compile-time verification of template
		Doubler() {}
		friend T;
	};

	// Ultimatly, this is the class used which contains the above defined functionalities
	class MyFunctionality : public Scaler<MyFunctionality>, public Doubler<MyFunctionality>{
	private:
		int m_Value;
	public:
		explicit MyFunctionality(int val) : m_Value{ val } {}
		int getValue() const { return m_Value; }
		void setValue(int val) { m_Value = val; }
		
	};
}